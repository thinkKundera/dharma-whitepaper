# Dharma（达摩）: 债务发行代币化的通用协议

版本 2.0

Nadav Hollander -- nadav@dharma.io

斯坦福大学2017级计算机学士


## 摘要
达摩是一个区块链协议，可以在其具有高度通用性的架构中，实现去中心化的发起，承销，发行和管理代币化的债务资产。该协议旨在建立一个通用的信息界面，交易所，经纪商和交易商可以通过该界面合理定价代币化债务的违约风险，而无需依赖单一的中心化数据经纪人。达摩协议债券发行计划利用了两种角色在不同的市场竞争以补偿费用 - 承销商和中介机构。前者是可信发起人和债务人违约风险的评估人，后者以无需信赖的方式促进债务融资和发行债务。两者都可以根据历史资产表现进行实证评估，因此，市场有清晰的信号来评估任何特定承销商或中介机构所断言的代币化债务的违约风险。达摩协议的债务发行全过程只需要一个链上交易即可，该协议受到了0x协议很大的启发。


## 引言

> 声明：区块链的一个未被充分认识的优势是，它们必然会导致对代币化资产类别的通用的、无需许可的标准的创建。

就在本文撰写之时，代币众筹模式仅在2017年就筹集了超过20亿美元。如果这证明了什么的话，那就是市场对众筹类产品的需求明显得不到满足，这类产品对散户投资者来说具有类似股票的风险特质。然而，股权众筹机制早在“ICO”就出现了——那么，如何解释这种市场对于ICO突然爆发的兴趣呢？如果股权众筹在技术上是可行的，而且已经实际运行很多年了，那么从技术的角度来看，以太坊构建的代币销售生态在哪些方面是独一无二的呢？我认为答案是很简单的：ERC20代币标准创建了共轨，在该共轨上可以以无需许可的和可互操作的方式构建多样化的虚拟代币二级市场生态体系。仅从投资流动性的角度来判断，代币众筹已是对股权融资现状的逐步改善。<sup>[译1](#t-1)</sup>

但在现有的金融体系中，与在债务融资领域“老大哥”相比，股权融资中筹集的资金总额微不足道。然而，债务市场仍然是不透明且专有的；在公开发行或私人投资者中进行债务融资，就像执行股权融资一样，是定制而低效的。这引发我们的思考：为什么不将代币众筹的模式应用于债务融资？


举一个简单的例子，一个公司其实可以发行债券作为一种“债务ICO”，并将代表债券所有权的ERC20代币通过众筹的方式出售。这样看来，一个债务资产可以由无需许可、通用的代币标准来代表的世界，从流动性和透明度的角度来看，将会是一种超越现状的逐步改善。为了让相应的二级市场出现，投资者需要一种标准化的定价机制来计算债务资产的价格。类似于股票的代币价值与品牌协议、项目或底层实体绑定在一起，而类似于债务的代币则在价值上与通常是匿名的对手方的历史财务活动相关联。ERC20标准没有涵盖债务资产的强制性语义，因为它没有提供一种方法以支持:

* 提取机器可读的特定于债务的元数据(如本金、利率等)。
* 从债务资产的条款中提取债务人和债权人之间的偿付历史。
* 将违约风险纳入债务资产的价值中。

达摩协议旨在填补这一空白，并提供一种无需许可的、通用的机制。通过这种机制，各种类型的债务资产可以被发行、出售、管理和定价，而不必依赖任何一种中心化的数据经纪人。

## 架构
达摩协议定义了一种通过一套智能合约、监护人市场和下面将详细阐述的标准化接口来发行、资助、管理和交易债务资产的程序。受到0x去中心化交易协议的启发。我们将采用0x的广播订单信息接口（Broadcast Order Messages）作为达摩系统中与之地位类似的达摩债务订单（Dharma Debt Orders）的蓝图，这一机制将在本文中被进一步明确。该协议旨在支持EVM区块链，但也可以扩展为支持任何带有智能合约功能的区块链。首先，我们对文中会出现的一些术语进行解释。

### Agents·代理
我们将**代理**定义为协议的最终使用者——即寻求借入或借出加密货币的实体。这些实体，不管是人、公司、合同还是自动机，都可以毫不意外地分为两类:
- 债务人：债务交易中借用资产的一方，并欠债权人某一约定的价值。
- 债权人：债务交易中借出资产的一方，债务人欠其某一约定的价值。


### Keeper Marketplaces·监护人市场
我们采用了一个包罗万象的术语“监护人”，来囊括那些为网络提供增值服务并在各自的市场上竞争以获取手续费的服务提供商。

![不同代理与监护人的交互流程图](https://s3-us-west-2.amazonaws.com/dharma-assets/WhitepaperV2Architecture.png)

#### 1. Underwriters·承销商
在传统的债务市场中，承销商是通过管理公共发行的债务和定价借款人违约风险而收取费用的实体。在达摩协议中，这个定义被扩展和形式化为：一个受到信任的实体，它为履行以下职能收取由市场确定的费用:
- 帮助借款人起草债务订单
- 与潜在债务人确定并协商债务条款(即期限、利息、摊销)
- 加密地记录其将某项具体债务关系断定为违约的可能性(此流程将在下文规范中具体描述)
- 管理债务订单的资金，并将其转寄给任何数量的中继节点
- 偿还债务，即在承销商的合理能力下，尽一切所能确保按协议条款及时还款
- 在违约或拖欠情况下，通过法律机制收集抵押品(若债务被担保)或个人资产，并将所得收益转给债权人

这其实与大多数在线贷款机构在日常承销和偿还业务中所做的事情并无二致。我们相信达摩协议将为那些有抱负的在线借贷平台提供另一种更廉价的途径，来促进他们的业务，并获得类似的利润。他们将成为承销商，这样一来就不再需要担心资产负债表风险。同时也避免了开展业务之前，从传统投资者那里筹集必要的债务工具，所带来的时间和资本成本。

> 例：Alice对于如何为ZCash矿工提供发起、承销和偿还贷款有一些新颖的想法，这些旷工往往需要大量的前期资金来购买大量的GPUs。Alice没有去找传统固定收益投资者，而是决定成为一名达摩协议的承销商。她设法获得了必要的贷款从业执照，建立了一个为矿工提供广告服务的网站，并在ZCash社区为她的信贷产品大肆宣传。当借款人来到她的网站时，他们的信用度会被Alice的商用技术自动评分，他们会按照Alice的要求给出贷款条款。在接受了条款之后，Alice加密的断言借款人违约的可能性，将已签署的债务订单转发给了一个中继者，并在贷款的总资金上收取了她想要的费用。整个资金的流动是透明的，可审计的，而爱丽丝在偿还债务方面的能力也可以根据其过往的历史记录来确定。

#### 2. Relayers·中继节点
达摩协议的中继节点与0x协议的中继节点会执行类似的功能：中继节点聚合已签名的债务订单消息，以获得事先约定的费用。它将信息集中在一个集中的订单簿上，并为散户投资者提供投资于其所要求的债务订单的能力。值得注意的是，与0x的中继机制类似，达摩协议的中继节点无需持有任何代币——它们只是提供了一个机制，让债权人可以浏览聚合起来的已被签名的债务订单消息。债权人可以使用该机制来无需信任地发行自己的债务代币，并通过客户端合约的交互给出被请求的本金，(该机制将在本文后面具体介绍)。达摩协议和0x协议的中继节点之间的主要区别是：
- 达摩协议的中继节点不托管二级市场的订单薄，而是托管尚未发行的债务请求的订单薄。
- 达摩协议的中继节点为债权人提供了与债务订单消息及其附带的承销商相关的元数据，这样他们就可以对给定的债务订单的风险状况作出知情的投资决策。
- 达摩协议的中继节点不允许匿名地在订单簿上发布已签名的债务订单。并且他们会审慎地只接受已知的、可信的承保人提交的债务订单。

> 例：Bob希望建立一个零售贷款投资者的门户，用户可以通过该门户投资各种债务资产。可以将其理解为p2p贷款的携程网。Bob通过建立一个在线订单簿，建立了一个零售投资平台，允许投资者浏览债务请求，并审查有关债务人的信用分数和承销商的身份数据，从而成为了达摩协议的中继节点。Bob基于其看到的Alice之前为资产背书的历史表现与她的预测一致，并且知道Alice的公司是一个受公众信任和受监管的实体，Bob允许Alice在他的订单薄上广播已签名的债务订单。当一个债务订单在他的平台上成交时，Bob就收到该订单中所规定的手续费。

## 智能合约

达摩协议利用了几个部署在以太坊网络上的智能合约，这里介绍其中几个与理解协议机制特别相关的合约。

### 1. Debt Kernel · 债务核心合约
债务内核是一个简单的智能合约，它管理所有与铸造非同质化（non-fungible）债务代币相关的业务逻辑，维护债务代币与其相关的债务条款合约之间的映射，将还款从债务人转移到债权人，并将相关的手续费发送给承保人和中继者。这些机制在介绍债务生命周期的上下文中更容易定义，在下面的规范中将得到广泛的阐述。

### 2. Terms Contract · 债务条款合约
债务条款合约是以太坊上的智能合约，是债务人和债权人就共同的、确定的偿还条款达成一致的手段。通过拓展，合约将暴露出一种标准的方式来登记债务人的还款，并可以通过程序在贷款期限内和还款之后查询贷款的偿还情况。一个条款合约可以被用于任何符合其还款条件的债务协议——例如，一个定义了简单的复合利息偿还计划的条款合约可以由任意数量的债务人和债权人承担。下面的规范中将具体定义该接口。

> 注：承诺贷款条件的另一种方案是在对记录在链上的文本形式的贷款条款进行承诺，然后在链下对债务人的申请进行评估。出于若干原因，我们有意选择不推行这种方案。首先，明确定义债务条款的通用模式可以在协议中限制债务资产类型的范围，而通用的协议接口则为无限的债务条款合约打开了大门。此外，在链上通过智能合约来承诺条款将消除对贷款还款状态的评估的任何不确定性——合约是一个单一的、程序化的、不可变的事实来源，它是由契约和客户端查询的。最后，拥有一个在链上的还款状态数据源，将大大简化担保债务协议的实现，使得当违约情况发生时有效地使用担保来进行偿付。

### 3. Repayment Router · 偿还路由合约
偿还路由合约的建立是为了无需信任地将还款从债务人转移到债权人(即债务代币的所有者)。此外，偿还路由合约还可作为一个可信的Oracle，向与债务协议相关联的债务条款合约报告每一笔还款的具体细节。这使债务条款合约可作为一个可信赖的接口来确定债务的违约状态。


## 规范

### 概述
当向债务核心合约提交一份已签名的债务订单信息时，整个债务发行过程将同步地发生在一个链上交易中。如果消息符合下面的规范定义，那么在这个交易中会发生以下过程：
- 债务人对所选择的条款的遵守承诺和保险人对违约可能性的预测将被记录到链上
- 一枚非同质化、不可分割的债务代币，将被铸造给债权人，该代币将与上述承诺相映射
- 本金（扣除费用后）从债权人转移到债务人，任何监护者的费用也将从债权人处扣除，并分发给相应的角色

整个过程如下所示。首先，我们在协议中定义了数据包的格式。

### 报文类型

在协议中，不同的代理和监护人之间的通信，是由我们称为债务订单（Debt Orders）的数据包组成的。

#### Debt Orders·债务订单

债务订单是由中继节点列出的数据包，它们是达摩协议的基本元素：向债务内核提交有效的债务订单，可以触发债务代币的发行，并与所请求的本金金额进行交换。达摩协议不限制债权人、债务人、承销商和转让人之间相互沟通和转让债务订单的方式，债务订单最多可以有3个ECDSA签名：债务人的签名、债权人的签字和承销商的签名。

他们需要签名的具体数据，取决于他们在整个交易中所扮演的角色：债务人和债权人被要求签署债务订单的哈希(即债务订单哈希)，而承销商只需要在债务订单中签署部分数据，我们称之为承销商承诺（underwriter commitment）。

此外，并非所有3个签名都必须附在债务订单上，才能提交给债务内核：如果一个代理或监护人没有参与交易(即债务订单中他们的地址为空)，或者他们参与了交易，但同时也是提交债务订单到债务内核合同的一方，那么他们的签名就不是必须的。

债务订单由下列字段组成:

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`kernelVersion` | 内核版本 | `address` | 债务核心合同的地址。协议升级时，这个地址将被更新。
`issuanceVersion` | 发行版本 | `address` | 与此发行承诺相关的偿还路由合约的地址。
`principalAmount` | 本金数量 | `uint256` | 债务人请求的本金数量。
`principalToken` | 本金代币类型 | `address` | 本金代币的ERC20合约地址。
`debtor` | 债务人 | `address` | 请求借贷的债务人地址
`debtorFee` | 债务人应付手续费 | `uint256` | 将从债务人的本金中扣除的总手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`creditorFee` | 债权人应付手续费 | `uint256` | 债权人在本金基础上需支付的额外手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`relayer` | 中继节点 | `address` | 挂单了本债务订单的中继节点地址
`relayerFee` | 中继节点应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付中继节点的手续费。
`underwriter`| 承销商地址 | `address` | 为该债务资产评级的承销商的地址。
`underwriterFee` | 承销商应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付承销商的手续费。
`underwriterRiskRating` | 承销商给出的风险评级 | `uint32` | 承销商给出的债务人对单位价值债务的平均偿还可能性的量化评估。必须介于0和1之间，编码为一个无符号整数，表示有9位小数（也就是说，50%的可能性将被表示为500000000）
`termsContract` | 条款合约 | `address` | 条款合约的地址，该合约定义了债务还款的条款细则。
`termsContractParameters` | 条款合约参数 | `bytes32` | 条款合同中与偿还条款相关的具体参数（如本金、利率等）。
`expirationTimestamp` | 过期时间 | `uint256` | 在这个时间点后若还未成交，该订单即过期
`salt` | 盐（混淆参数）| `uint` | 伪随机的混淆参数用来区分那些具有同样参数的不同订单的哈希值

#### Debt Issuance Commitments · 债务发行承诺
债务发行承诺是我们单独考虑的债务订单数据包的一个子集，以便为任何给定的债务协议定义一个规范的、唯一的标识符。债务发行承诺表达了债务人(和承销商)想要铸造一枚非同质性的债务代币，在这种情况下，债务代币将不可修改地与元组`(TC, P)`相关联，`TC`是一个已部署的条款合约的地址，该合约遵守了条款合约接口(见下文)，`P`代表了在`TC`合约中所使用的一组参数。此外，承销商承诺一个值`R`，代表承销商对债务人将按照`(TC, P)`所定义的任何给定的单位价值进行偿付的平均可能性的评估。该子集数据包的哈希被称为**发行哈希**，它在整个协议中被用作债务协议的规范唯一标识符。

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`issuanceVersion` | 发行版本 | `address` | 与此发行承诺相关的偿还路由合约的地址。
`debtor` | 债务人 | `address` | 请求借贷的债务人地址
`underwriter`| 承销商地址 | `address` | 为该债务资产评级的承销商的地址。
`underwriterRiskRating` | 承销商给出的风险评级 | `uint32` | 承销商给出的债务人对单位价值债务的平均偿还可能性的量化评估。必须介于0和1之间，编码为一个无符号整数，表示有9位小数（也就是说，50%的可能性将被表示为500000000）
`termsContract` | 条款合约 | `address` | 条款合约的地址，该合约定义了债务还款的条款细则。
`termsContractParameters` | 条款合约参数 | `bytes32` | 条款合同中与偿还条款相关的具体参数（如本金、利率等）。
`salt` | 盐（混淆参数）| `uint` | 伪随机的混淆参数用来区分那些具有同样参数的不同订单的哈希值

#### Debtor/Creditor Commitment Hash · 债务人/债权人承诺哈希
债务人/债权人承诺哈希是有债务人或债权人签名的有效载荷，以表明他同意该债务订单上的参数。它由以下债务订单参数子集的Keccak256哈希组成:

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`kernelVersion` | 内核版本 | `address` | 债务核心合同的地址。协议升级时，这个地址将被更新。
`issuanceHash` | 发行哈希 | `bytes32` | 上面描述的债务发行承诺的哈希值，作为债务协议的通用标识符。
`principalAmount` | 本金数量 | `uint256` | 债务人请求的本金数量。
`principalToken` | 本金代币类型 | `address` | 本金代币的ERC20合约地址。
`debtorFee` | 债务人应付手续费 | `uint256` | 将从债务人的本金中扣除的总手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`creditorFee` | 债权人应付手续费 | `uint256` | 债权人在本金基础上需支付的额外手续费。请注意，债务人和债权人支付的总手续费应等于付给承销商和中继节点的全部费用。
`relayer` | 中继节点 | `address` | 挂单了本债务订单的中继节点地址
`relayerFee` | 中继节点应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付中继节点的手续费。
`underwriterFee` | 承销商应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付承销商的手续费。
`expirationTimestamp` | 过期时间 | `uint256` | 在这个时间点后若还未成交，该订单即过期

#### Underwriter Commitment Hash · 承销商承诺哈希
承销商承诺哈希是承销商签名的有效载荷，以表明他同意债务订单上的参数。承销商需要为一个不同的参数子集签名，使得债务人不需要向每个为他们广播其债务订单的中继节点申请新的签名。我们将在下面进一步阐述。

字段 | 含义 | 数据类型 | 描述 
----| -------- |------| ---
`kernelVersion` | 内核版本 | `address` | 债务核心合同的地址。协议升级时，这个地址将被更新。
`issuanceHash` | 发行哈希 | `bytes32` | 上面描述的债务发行承诺的哈希值，作为债务协议的通用标识符。
`principalAmount` | 本金数量 | `uint256` | 债务人请求的本金数量。
`principalToken` | 本金代币类型 | `address` | 本金代币的ERC20合约地址。
`underwriterFee` | 承销商应收手续费 | `uint256` | 当债务人与债权人的关系最终确定时，将由债务核心支付承销商的手续费。
`expirationTimestamp` | 过期时间 | `uint256` | 在这个时间点后若还未成交，该订单即过期


综上所述，如果以下签名均已附上，则该债务订单被认为已准备好提交:
1. 债务人对债务人/债权人承诺哈希的ECDSA签名。(除非向达摩智能合约提交订单的地址为该债务人)
2. 承销商对承销商承诺哈希的ECDSA签名。(如果没有承销商，或向达摩智能合约提交订单的地址为该承销商，可以省略该签名)
3. 债权人对债务人/债权人承诺哈希的ECDSA签名。(除非向达摩智能合约提交订单的地址为该债权人)


### 债务发行流程
任何拥有有效的债务订单，并附带必要的附加签名的人，都可将该订单提交至达摩智能合约。将债务订单提交到达摩智能合约后，一个债务协议代币将被铸造并与本金同步交换。我们将债务人完成的债务订单称为“债务人完成的订单提交”（Debtor-Filler Order Submissions），并将债权人完成的债务订单称为“债权人完成的订单提交”（Creditor-Filler Order Submissions）。


#### 债权人完成的订单提交
![](https://s3-us-west-2.amazonaws.com/dharma-assets/Creditor-Filler+2.png)

以下步骤与上图中的圈中数字相对应:

1. 债务人向承销商申请贷款。
2. 在债务人、承销商和中继节点间将发生债务订单握手（下文将详细描述），完成后中继节点挂出一个有效的、完整的债务订单。
3. 债权人对中继节点维护的公共订单薄上的债务订单进行评估。
4. 如果债权人想要完成订单，他首先会授权代币转让代理（token transfer proxy）可以转让大于等于本金加上债权人费用的代币（即使用ERC20的`approve`函数）。请注意，此步骤不必在债权人填写的每一个订单中重复，债权人可以向代币转移代理进行一次授权，使该代理有权限转移很大数量的代币。智能合约将保证只有当他通过提交或为一份债务订单提供签名的时候，合约才会从他的帐户中取出相应的代币。
5. 然后债权人将其直接提交给债务核心合约。请注意，在这一步中不需要他的签名，因为他向内核提交的订单就已经暗示了他同意其参数。
6. 债务核心接着向债权人发放一个非同质性、不可分割的令牌，代表债务人对合同和相关参数的承诺。
7. 债务内核将数量为`本金-债务人手续费`的贷款转入债务人账户。
8. 债务内核将定义在债务订单中的承销商手续费转入承销商账户。
9. 债务内核将定义在债务订单中的中继节点手续费转入中继节点账户。

债务人创建订单的情形，对有许多潜在债权人而且债务人对最终获得贷款的时间没有太多要求的情况有利。

#### 债务人完成的订单提交

![](https://s3-us-west-2.amazonaws.com/dharma-assets/Debtor-Filler+2.png)

以下步骤与上图中的圈中数字相对应:
1. 债务人向承销商申请贷款。
2. 在债务人、承销商和中继节点间将发生债务订单握手（下文将详细描述），完成后中继节点挂出一个有效的、完整的债务订单。
3. 债权人对中继节点维护的公共订单薄上的债务订单进行评估。
4. 如果债权人想要完成订单，他首先会授权代币转让代理（token transfer proxy）可以转让大于等于本金加上债权人费用的代币（即使用ERC20的`approve`函数）。然后，在债务订单的债务/债权人承诺协议里附上其ECDSA签名。
5. 债权人将已签署的债务订单提交给中继节点。
6. 中继节点将已签署的债务订单转发给债务人。
7. 债务人在方便的时候将签署的债务订单提交给债务内核，这将发行一个独特的、非同质性债务订单代币给债权人，使其成为债务订单的最终签字人。
8. 债务内核将数量为`本金-债务人手续费`的贷款转入债务人账户。
9. 债务内核将定义在债务订单中的承销商手续费转入承销商账户。
10. 债务内核将定义在债务订单中的中继节点手续费转入中继节点账户。


债务人完成方案对于债务人希望同步地借用代币，并且每一笔交易可以是一系列更复杂交易中的一部分，这样的场景是有利的。例如，如果一个智能合约要求用户支付一定数量用于存储的代币(如FileCoin、Storj等)，为了使用它，用户可以通过上述方案获得一个有效的、已签名的债务订单来作为智能合约函数调用的一个参数。然后，智能合约可以将债务人的订单提交给债务内核，同时向债务人提供必要的存储代币，然后在同一笔交易中将其记入智能合约。这大大减少了在几乎任何情况下信用借贷情景里执行交易的摩擦成本。

#### Debt Order Handshake · 债务订单握手流程
上面提到的债务订单握手流程被正式地定义如下：
![](https://s3-us-west-2.amazonaws.com/dharma-assets/DebtOrderHandshake-DebtorMaker.png)

1. 债务人从指定的承销商处请求其承销的债务，列举他想要的贷款条件（即本金类型、期限等）。
2. 承销商使用专有风险模型评估债务人的违约风险，构建承销商承诺(同时需要构建债务发行承诺)，将其ECDSA签名附到承销商承诺的哈希上，并将债务发行承诺、承销商承诺和ECDSA签名发送给债务人。
3. 如果参数符合债务人的期望条件，债务人现在便拥有了所有必要的参数来构建一个完整的债务订单。但如果他希望将订单转给潜在的债权人，债务人将需要一个中继节点（主要是该节点的费用计划和地址）。
4. 中继节点以他的费用计划和地址回应债务人的请求。
5. 如果中继节点的费用符合债务人的意愿，债务人将使用承销商和中继节点提供的参数构建一个完整的债务订单，并将订单发送给中继节点。
6. 中继者在他们的订单簿上列出完整的债务订单。他们挂出订单就已默认表明其接受订单上的所有参数，故其签名不是必要的。

#### Debt Repayment Process · 债务偿还流程
为了使任何债务资产的偿还状况都能得到实证评估，我们定义了一个偿还流程，在偿还流程中，还款是由偿还路由合同引导完成，整个过程将不可修改地记录在链上。

当债务人希望偿还债务时，他们将执行以下操作:
1. 债务人向代币转让代理授予转让限额(即通过ERC20 `approve` 函数)，其数额大于或等于所期望的偿还金额。
2. 债务人将一个交易发送到还款路由合约，并附带上参数确定的所需还款金额。然后，还款路由合约将获取该债务的当前受益人的地址(即债务代币的持有者)，将所期望的还款金额从债务人的帐户转移到受益人的帐户上，并调用债务的条款合同中的 `registerRepayment` 方法登记该笔还款。

注意：我们可以构建一个简单得多的方案，在这个方案中，债务人直接向债权人偿还债务，而不需要利用债务内核合约。然而，实际上有必要让对于债务内核介入到偿还过程中，以确保当一笔还款在给定的条款合同中登记时，有一笔还款交易与之对应。

### Terms Contract Interface · 条款合约接口
我们要求通过达摩协议所发行的任何债券都承诺签订一份“智能合约”，即条款合约。条款合约的作用是提供一个不可变的、程序化的、可证明的可信来源，来揭示债务的偿还状态。这使我们能够以经验和明确的方式在债务发行过程中定义还款计划，并在债务的生命周期中对债务的偿还状况进行评估。所需要的功能接口如下：

```
/// 条款合约接口
interface TermsContract {
     /// 登记债务人的偿还交易，并附带上一些元信息，如对美元汇率等。
     /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
     /// @param  payer address. The address of the payer.
     /// @param  beneficiary address. The address of the payment's beneficiary.
     /// @param  unitsOfRepayment uint. The units-of-value repaid in the transaction.
     /// @param  tokenAddress address. The address of the token with which the repayment transaction was executed.
    function registerRepayment(
        bytes32 agreementId,
        address payer,
        address beneficiary,
        uint256 unitsOfRepayment,
        address tokenAddress
    ) public returns (bool _success);

    /// 一个registerRepayment的变种，将还款信息记录在NFT代币中。
    /// to determine ex post facto the value repaid (e.g. current USD
    /// exchange rate)
    /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
    /// @param  payer address. The address of the payer.
    /// @param  beneficiary address. The address of the payment's beneficiary.
    /// @param  tokenId The tokenId of the NFT transferred in the repayment transaction
    /// @param  tokenAddress The address of the token with which the repayment transaction was executed.
    function registerNFTRepayment(
        bytes32 agreementId,
        address payer,
        address beneficiary,
        uint256 tokenId,
        address tokenAddress
    ) public returns (bool _success);

     /// 返回到特定区块高度时，累计需要偿还的价值单位。
     /// 注意这不是一个常量函数，函数的返回值对于给定的区块高度也可能发生改变，因为利率可能会在交易几方间被重新协调。
     /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
     /// @param  blockNumber uint. The block number for which repayment expectation is being queried.
     /// @return uint256 The cumulative units-of-value expected to be repaid by the time the given blockNumber lapses.
    function getExpectedRepaymentValue(
        bytes32 agreementId,
        uint256 blockNumber
    ) public view returns (uint256);

     /// 返回到特定区块高度时，累计已偿还的价值单位。
     /// @param  agreementId bytes32. The agreement id (issuance hash) of the debt agreement to which this pertains.
     /// @param blockNumber uint. The block number for which repayment value is being queried.
     /// @return uint256 The cumulative units-of-value repaid by the time the given blockNumber lapsed.
    function getValueRepaid(
        bytes32 agreementId,
        uint256 blockNumber
    ) public view returns (uint256);
}
```

请注意，在`getExpectedRepaymentValue`和`getValueRepaid`函数中，还款数量被抽象地定义为了“价值单位”。
我们有意地没有定义偿还债务的单位，这使得债券发行人有了更多的灵活性。比如说，在执行代币的实际交易时，可以用法定货币来表示预期的偿还价值。


### 违约和收债
达摩协议对承销商处理违约的手段和回收债务的方式不加限制。很容易想到的是，承销商可以通过利用法院来发行具有法律约束力的链下借贷协议，并通过借助法律来收回债务。当然也可以使用链上担保机制，利用某一特定债务的承诺条款合约所提供的功能，一旦当前价值偿还能力低于预期价值的偿还能力，就立即去中心化地向债权人发放抵押品。

无数其他的方案可以被用来抑制违约，达摩协议不会提倡或设计任何特定的解决方案，而是旨在提供一种标准机制，通过这种机制来研究承销商对于债务资产的评级历史，以评估承销商的表现。市场应该倾向于奖励那些过去表现强劲的承销商，反之亦然。承销商过去绩效的衡量标准，我们称之为`F_β`，它借鉴了统计分析中二元分类器的评估函数，目的是为了评估承销商对违约预测的准确性：

- 定义：`x` ∈ 1,...,n 是承销商评级的债务
- 定义：`α_x` 是债务`x`合约到期时，债务人期望偿还的总价值。
- 定义：`γ_x` 是债务`x`合约到期时，债务人实际偿还的总价值。
- 定义：`δ_x` 是在承销商的预测中，债务`x`违约的可能性。
- 定义：`β`为调整召回率对准确性重要程度的超参数。

```
p=∑{x}min(α_x−γ_x,δ_x*α_x)/∑{x}δ_x*α_x 
r=∑xmin(α_x−γ_x,δ_x*α_x)/∑_x(α_x−γ_x) 
F_β=(1+β^2)*p*r/β^2*p+r 
```

需要重点强调，这不是一个对承销商的表现进行评估时完全可靠且无所不包的度量指标。恶意欺诈的承销商可以通过各种方式(参见"攻击"小节)来博弈该指标。更确切地说，这是一个经验信号，善意的、可信的承销商可以被透明地评估。当市场上的承销商都值得信赖时，该指标将是一个非常有价值的信号。


# 使用案例
债务是一种非常多样化的资产类别，理论上，几乎任何类型的债务协议都可以通过达摩协议来发行和承销。
从事任何类型法币借贷业务的在线放贷机构，都可以将他们的后台迁移到达摩协议上。他们只需在每一笔发出的交易中同时扮演债务人和承销商的角色，将本金支付转化为收据上的法币,并确保所有借款人支付和偿还均使用法币，这样便可以对用户完全隐藏那些贷款流程链上部分的复杂细节。
我们认为，这最终将为寻求债务资本的在线贷款机构提供一个有吸引力的替代途径。


然而，在短期内，链上债务发行的更有说服力的使用场景将是那些仅能在链上实现或因为使用了区块链而使用体验得到大大提高的场景。下面我们将重点介绍其中的几个:




<a name="t-1">step-function improvement</a>: http://www.businessinsider.com/step-function-growth-2010-12/?IR=T

